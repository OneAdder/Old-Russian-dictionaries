# Установка
Установка с помощью пакетных менеджеров не предусмотрена. Следует просто клонировать репозиторий.

`git clone https://github.com/OneAdder/Old-Russian-dictionaries`

# Запуск
Для запуска веб-приложения следует третьим Питоном запустить `old_rus_dictionaries.py`

Зависимости: `Flask`, `cython3`.



Для запуска обработки словарей следут запустить Башем скрипт `data_processing/match.sh` (пользователи Windows могут запустить Питоном скрипты по порядку: `data_processing/tei_parser.py`, `data_processing/matcher.py` и `data_processing/finish_match.py`). Результаты выведутся в файл `data_processing/matched.json`.

Зависимости: `cython3`, `pandas`, `bs4`.

# Устройство данных
Устройство JSON-файла `data_processing/matched.json`


```
{
    унифицированная_лемма (str):
     {
        "avanesov_lemma": XI-XIV_лемма (str),
        "avanesov_data": {
            "gramGrp": граматический_клас (str),
            "definition": определение (str),
            "usg": использование (str),
            "inflected": изменяемый/неизменяемый (bool),
            "examples": 
            [
                {
                    "example": пример (str),
                    "src": источник (str)
                },
                ...
            ],
            "inflection": {формы (dict)}
        },
        "XVII_lemma": XI-XVII_лемма (str),
        "XVII_lemma_index": ещё_одна_лемма_из_того_же_словаря (str),
        "XVII_link": ссылка_на_пдф (str)
    },
   ...
}
```

# Библиотека unification
Мы создали библиотеку `data_processing/unification.pyx`. 
Для работы с библиотекой требуется установить пакет `cython3`. Далее её можно импортировать следующим образом:
```
import pyximport; pyximport.install()
import unification
```
Эта библиотека на языке Cython содержит ряд полезных для работы с древнерусскими вариантами написания функций.

### unify
unification.**unify** принимает слово `str` и приводит его к единому формату. Таким образом, можно сравнить два слова: если они одинаковые (например, "вседержитель" и "вьседержитель"), то `unify` выдаст один результат для обоих слов.  
```
>>> unify('вьседержителъ')
'въсєдєръжитєлъ'
>>> unify('всєдєржитєль')
'въсєдєръжитєлъ'
```
### all_options
unification.**all_options** принимает слово `str` и выводит все способы перевода в унифицированную графику, учитывая разнообразие способов постановки редуцированных. 
```
>>> all_options('мълъва')
('молъва', 'мълъва', 'молъва')
```
Данная функцию нужна, так как не всегда можно предугадать все возможные позиции редуцированных (`unify` лишь даёт наиболее вероятный вариант).  
Пока не найдено нормальное слово, где это может пригодиться, так что пример ниже искуственный. Как видно функция `unify` выдаёт разные варианты для слов, которые требуется сметчить, в том время как `all_options` выдаёт кортеж, который содержит вариант, введённый во втором вызове функции `unify`, а также вывод обоих вызовов этой функции.  
Этот даёт возможность сметчить варианты "тъттъ", "тотътъ", "тътътъ" и "тътотъ".
```
>>> unify('тъттъ')
'тотътъ'
>>> unify('тътътъ')
'тътотъ'
>>> all_options('тъттъ')
('тотътъ', 'тътътъ', 'тътотъ')
```
### compare
unification.**compare** принимает два слова `str`, сравнивает, если формы одинаковые, то возвращает унифицированную форму, совместимую с выводом функции `unify`. Если слова нужно сметчить, то функция возвращает слово в унифицированном виде. Если слова разные, функция не возвращает ничего.  
Данная функция так же поддерживает расширенную проверку позиций редуцированных, однако не рекомендуется к использованию, если вы подозреваете что такое (лучше присмотреться к `safe_conparison`).
```
>>> compare('вьседержителъ', 'всєдєржитєль')
'въсєдєръжитєлъ'
>>> compare('тътътъ', 'тътотъ')
'тътотъ'
>>> compare('тътътъ', 'тъттъ')
'тътотъ'
```
### full_comparison
unification.**full_comparison** принимает два слова `str`, сравнивает и выдаёт все варианты, совпадающие для обоих слов.
```
>>> all_options('тъттъ')
('тотътъ', 'тътътъ', 'тътотъ')
>>> all_options('тътътъ')
('тътотъ', 'тътътъ', 'тътотъ')
>>> full_comparison('тъттъ', 'тътътъ')
['тътътъ', 'тътотъ', 'тътотъ']
```
### safe_comparison
unification.**safe_comparison** принимает два слова `str`, сравнивает.
Если есть совпадающие варианты, и хотя бы один из них совпадает с `unify(первое_слово)` или `unify(второе_слово)`, то возвращает именно этот вариант.
В противном случае не возвращает ничего. Если совпадений несколько, выдаётся первое. То есть в том порядке, как это писано в разделе про алгоритм.
```
>>> safe_comparison('тъттъ', 'тътътъ')
'тътотъ'
>>> safe_comparison('тттъ', 'тътътъ')
'тътътъ'
```

## Алгоритм унификации
### Алгоритм сделан на основе статей:
* "Автоматический морфологический анализатор древнерусского языка: лингвистические и технологические решения"
Баранов, Миронов, Лапин, Мельникова, Соколова, Корепанова.

* "ВЗIAЛЪ, ВЪЗЯЛЪ, ВЬЗЯЛ: ОБРАБОТКА ОРФОГРАФИЧЕСКОЙ ВАРИАТИВНОСТИ ПРИ ЛЕКСИКО-ГРАММАТИЧЕСКОЙ АННОТАЦИИ СТАРОРУССКОГО КОРПУСА XV–XVII ВВ." Т. С. Г АВРИЛОВА, Т. А. ШАЛГАНОВА, О. Н. ЛЯШЕВСКАЯ.

### Порядок действий
1. Привести к нижнему регистру, удалить лишние знаки и т.д.
2. Привести равнозначные знаки и фонологически незначимые отличия к единой форме. Подробнее см. докстринги `unify_various_symbols`.
3. Привести конечный редуцированный в "ъ".
4. Уменьшить разнообразие гласные после после шипящих. Подробнее см. докстринги `unify_vowels_after_set1`.
5. Дезйотировать гласные в позиции начала слова и после гласных. Подробнее см. докстринги unify_iotated
6. Перевести "ь" после йотированных гласных и "i" в "и".
7. Преобразовать ряд сочетаний плавных с гласными. Подробнее см. докстринги `unify_r_and_l_with_shwas1`, `unify_r_and_l_with_shwas2` и `unify_r_and_l_with_yat`.
8. Эмулировать падение редуцированных.
9. Добавить принцип открытого слога.

Последние два пункта используются в функции `unify`. В функциях `all_options`, `compare`, `full_comparison` и `safe_comparison` используется растроение возможного положения редуцированных. Сравнивается слово, полученное пунктами 1-7.
В слове проставляются редуцированные тремя способами:
1. Редуцированные упали/прояснились, "ъ" возник по принципу открытого слога.
2. "ъ" возник по принципу открытого слога.
4. "ъ" возник по принципу открытого слога, редуцированные упали/прояснились, "ъ" возник по принципу открытого слога.

Как видно первый вариант является стандартным алгоритмом и результат его работы совпадает с выводом функции `unify`. Остальные два варианта отличаются.

# Скрипт для обработки данных
Скрипт match.sh обрабатывает все имеющиеся данные и приводит в matched.json. Данный Bash-скрипт запускает скрипты на языке Python3. Порядок следующий:
1. `tei_parser.py`: парсит словарь Аванесова в формате `TEI` и сохраняет в `avanesov2.json`.
2. `matcher.py`: проходится по словарю Аванесова и ищет аналоги из словаря XI-XVII. Импортирует модули `match_cython` и `unification`, написанные на Cython. Сохраняет результат в `prematched.json`.
3. `finish_match.py`: вставляет данные из словаря XI-XVII, для которых не нашлось соответствий в словаре Аванесова, и сохраняет результат в `matched.json`.

# Использование
Данный код свободно распространяется под лицензией GNU GPLv3. Это значит, что вы можете свободно его использовать при условии, что оставите его открытым и упомяните его авторов.

Важно отметить, что данный репозиторий содержит не все
[PDF-документы](https://github.com/OneAdder/Old-Russian-dictionaries/tree/master/src/xi-xvii/pdf)
со словарём XI-XVII, а только несколько случайных в качестве примера (всех нет у нас самих). Данный словарь принадлежит его авторам, равно как и словарь Древнерусского языка XI-XIV Аванесова, представленный в виде
[этого](https://github.com/OneAdder/Old-Russian-dictionaries/blob/master/data_processing/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%20%D0%B4%D1%80%D0%B5%D0%B2%D0%BD%D0%B5%D1%80%D1%83%D1%81%D1%81%D0%BA%D0%BE%D0%B3%D0%BE%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%20(big).tei)
TEI-файла.

Также есть ряд материалов
([этот](https://github.com/OneAdder/Old-Russian-dictionaries/blob/master/data_processing/wordlist_linked.csv)
файл, а также HTML из
[этой](https://github.com/OneAdder/Old-Russian-dictionaries/tree/master/src/xi-xvii/html)
директории),
полученных нами анонимно, без документации и метаданных. В связи с этим, мы будем считать их общественным достоянием.

Если вы собираетесь использовать наш код в научных публикациях, нам будет приятно, если вы упомяните нас так же в благодарностях.
Скорее всего, мы так же будем заинтересованы принять участие.
